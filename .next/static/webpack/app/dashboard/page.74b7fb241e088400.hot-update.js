"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchPatientAppointments: function() { return /* binding */ fetchPatientAppointments; },\n/* harmony export */   fetchPatientData: function() { return /* binding */ fetchPatientData; },\n/* harmony export */   fetchPatientEncounters: function() { return /* binding */ fetchPatientEncounters; },\n/* harmony export */   fetchPatientLabReports: function() { return /* binding */ fetchPatientLabReports; },\n/* harmony export */   fetchPatientMedications: function() { return /* binding */ fetchPatientMedications; },\n/* harmony export */   fetchPatientProcedures: function() { return /* binding */ fetchPatientProcedures; },\n/* harmony export */   fetchPatientVitals: function() { return /* binding */ fetchPatientVitals; }\n/* harmony export */ });\nconst FHIR_BASE_URL = \"https://fhir.epic.com/interconnect-fhir-oauth/api/FHIR/R4\" || 0;\nconst fetchPatientData = async (patientId, accessToken)=>{\n    const response = await fetch(\"\".concat(FHIR_BASE_URL, \"/Patient/\").concat(patientId), {\n        headers: {\n            \"Authorization\": \"Bearer \".concat(accessToken),\n            \"Accept\": \"application/fhir+json\"\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to fetch patient data\");\n    }\n    return response.json();\n};\nconst fetchPatientMedications = async (patientId, accessToken)=>{\n    const response = await fetch(\"\".concat(FHIR_BASE_URL, \"/MedicationRequest?patient=\").concat(patientId, \"&status=active&_sort=-date&_count=10\"), {\n        headers: {\n            \"Authorization\": \"Bearer \".concat(accessToken),\n            \"Accept\": \"application/fhir+json\"\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to fetch patient medications\");\n    }\n    const data = await response.json();\n    return data.entry ? data.entry.map((e)=>e.resource) : [];\n};\nconst fetchPatientVitals = async (patientId, accessToken)=>{\n    const response = await fetch(\"\".concat(FHIR_BASE_URL, \"/Observation?patient=\").concat(patientId, \"&category=vital-signs&_sort=-date&_count=10\"), {\n        headers: {\n            \"Authorization\": \"Bearer \".concat(accessToken),\n            \"Accept\": \"application/fhir+json\"\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to fetch patient vitals\");\n    }\n    const data = await response.json();\n    return data.entry ? data.entry.map((e)=>e.resource) : [];\n};\nconst fetchPatientAppointments = async (patientId, accessToken)=>{\n    const response = await fetch(\"\".concat(FHIR_BASE_URL, \"/Appointment?patient=\").concat(patientId, \"&status=booked\"), {\n        headers: {\n            \"Authorization\": \"Bearer \".concat(accessToken),\n            \"Accept\": \"application/fhir+json\"\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to fetch patient appointments\");\n    }\n    return response.json();\n};\n// Add more API functions as needed for your application\nconst fetchPatientLabReports = async (patientId, accessToken)=>{\n    const response = await fetch(\"\".concat(FHIR_BASE_URL, \"/Observation?patient=\").concat(patientId, \"&category=laboratory&_sort=-date&_count=10\"), {\n        headers: {\n            \"Authorization\": \"Bearer \".concat(accessToken),\n            \"Accept\": \"application/fhir+json\"\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to fetch patient lab reports\");\n    }\n    const data = await response.json();\n    return data.entry ? data.entry.map((e)=>e.resource) : [];\n};\nconst fetchPatientEncounters = async (patientId, accessToken)=>{\n    const response = await fetch(\"\".concat(FHIR_BASE_URL, \"/Encounter?patient=\").concat(patientId, \"&_sort=-date&_count=10\"), {\n        headers: {\n            \"Authorization\": \"Bearer \".concat(accessToken),\n            \"Accept\": \"application/fhir+json\"\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to fetch patient encounters\");\n    }\n    const data = await response.json();\n    return data.entry ? data.entry.map((e)=>e.resource) : [];\n};\nconst fetchPatientProcedures = async (patientId, accessToken)=>{\n    const response = await fetch(\"\".concat(FHIR_BASE_URL, \"/Procedure?patient=\").concat(patientId, \"&_sort=-date&_count=10\"), {\n        headers: {\n            \"Authorization\": \"Bearer \".concat(accessToken),\n            \"Accept\": \"application/fhir+json\"\n        }\n    });\n    if (!response.ok) {\n        throw new Error(\"Failed to fetch patient procedures\");\n    }\n    const data = await response.json();\n    return data.entry ? data.entry.map((e)=>e.resource) : [];\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFDUCxpQkFBaUIsVUFBc0IsT0FBWkg7WUFDM0IsVUFBVTtRQUNaO0lBQ0Y7SUFFQSxJQUFJLENBQUNDLFNBQVNHLEVBQUUsRUFBRTtRQUNoQixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQSxNQUFNRyxPQUFPLE1BQU1QLFNBQVNLLElBQUk7SUFDaEMsT0FBT0UsS0FBS0MsS0FBSyxHQUFHRCxLQUFLQyxLQUFLLENBQUNDLEdBQUcsQ0FBQyxDQUFDQyxJQUFXQSxFQUFFQyxRQUFRLElBQUksRUFBRTtBQUNqRSxFQUFFO0FBRUssTUFBTUsseUJBQXlCLE9BQU9sQixXQUFtQkM7SUFDOUQsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLEdBQXNDSCxPQUFuQ0wsZUFBYyx1QkFBK0IsT0FBVkssV0FBVSwyQkFBeUI7UUFDcEdJLFNBQVM7WUFDUCxpQkFBaUIsVUFBc0IsT0FBWkg7WUFDM0IsVUFBVTtRQUNaO0lBQ0Y7SUFFQSxJQUFJLENBQUNDLFNBQVNHLEVBQUUsRUFBRTtRQUNoQixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQSxNQUFNRyxPQUFPLE1BQU1QLFNBQVNLLElBQUk7SUFDaEMsT0FBT0UsS0FBS0MsS0FBSyxHQUFHRCxLQUFLQyxLQUFLLENBQUNDLEdBQUcsQ0FBQyxDQUFDQyxJQUFXQSxFQUFFQyxRQUFRLElBQUksRUFBRTtBQUNqRSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYXBpLnRzPzJmYWIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRkhJUl9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZISVJfQkFTRV9VUkwgfHwgJyc7XG5cbmV4cG9ydCBjb25zdCBmZXRjaFBhdGllbnREYXRhID0gYXN5bmMgKHBhdGllbnRJZDogc3RyaW5nLCBhY2Nlc3NUb2tlbjogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7RkhJUl9CQVNFX1VSTH0vUGF0aWVudC8ke3BhdGllbnRJZH1gLCB7XG4gICAgaGVhZGVyczoge1xuICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vZmhpcitqc29uJ1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHBhdGllbnQgZGF0YScpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmZXRjaFBhdGllbnRNZWRpY2F0aW9ucyA9IGFzeW5jIChwYXRpZW50SWQ6IHN0cmluZywgYWNjZXNzVG9rZW46IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7RkhJUl9CQVNFX1VSTH0vTWVkaWNhdGlvblJlcXVlc3Q/cGF0aWVudD0ke3BhdGllbnRJZH0mc3RhdHVzPWFjdGl2ZSZfc29ydD0tZGF0ZSZfY291bnQ9MTBgLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2FjY2Vzc1Rva2VufWAsXG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vZmhpcitqc29uJ1xuICAgICAgfVxuICAgIH0pO1xuICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBwYXRpZW50IG1lZGljYXRpb25zJyk7XG4gICAgfVxuICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiBkYXRhLmVudHJ5ID8gZGF0YS5lbnRyeS5tYXAoKGU6IGFueSkgPT4gZS5yZXNvdXJjZSkgOiBbXTtcbiAgfTtcbiAgXG4gIGV4cG9ydCBjb25zdCBmZXRjaFBhdGllbnRWaXRhbHMgPSBhc3luYyAocGF0aWVudElkOiBzdHJpbmcsIGFjY2Vzc1Rva2VuOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0ZISVJfQkFTRV9VUkx9L09ic2VydmF0aW9uP3BhdGllbnQ9JHtwYXRpZW50SWR9JmNhdGVnb3J5PXZpdGFsLXNpZ25zJl9zb3J0PS1kYXRlJl9jb3VudD0xMGAsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9maGlyK2pzb24nXG4gICAgICB9XG4gICAgfSk7XG4gIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHBhdGllbnQgdml0YWxzJyk7XG4gICAgfVxuICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiBkYXRhLmVudHJ5ID8gZGF0YS5lbnRyeS5tYXAoKGU6IGFueSkgPT4gZS5yZXNvdXJjZSkgOiBbXTtcbiAgfTtcblxuZXhwb3J0IGNvbnN0IGZldGNoUGF0aWVudEFwcG9pbnRtZW50cyA9IGFzeW5jIChwYXRpZW50SWQ6IHN0cmluZywgYWNjZXNzVG9rZW46IHN0cmluZykgPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0ZISVJfQkFTRV9VUkx9L0FwcG9pbnRtZW50P3BhdGllbnQ9JHtwYXRpZW50SWR9JnN0YXR1cz1ib29rZWRgLCB7XG4gICAgaGVhZGVyczoge1xuICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vZmhpcitqc29uJ1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHBhdGllbnQgYXBwb2ludG1lbnRzJyk7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufTtcblxuLy8gQWRkIG1vcmUgQVBJIGZ1bmN0aW9ucyBhcyBuZWVkZWQgZm9yIHlvdXIgYXBwbGljYXRpb25cbmV4cG9ydCBjb25zdCBmZXRjaFBhdGllbnRMYWJSZXBvcnRzID0gYXN5bmMgKHBhdGllbnRJZDogc3RyaW5nLCBhY2Nlc3NUb2tlbjogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtGSElSX0JBU0VfVVJMfS9PYnNlcnZhdGlvbj9wYXRpZW50PSR7cGF0aWVudElkfSZjYXRlZ29yeT1sYWJvcmF0b3J5Jl9zb3J0PS1kYXRlJl9jb3VudD0xMGAsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9maGlyK2pzb24nXG4gICAgICB9XG4gICAgfSk7XG4gIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHBhdGllbnQgbGFiIHJlcG9ydHMnKTtcbiAgICB9XG4gIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIGRhdGEuZW50cnkgPyBkYXRhLmVudHJ5Lm1hcCgoZTogYW55KSA9PiBlLnJlc291cmNlKSA6IFtdO1xuICB9O1xuXG4gIGV4cG9ydCBjb25zdCBmZXRjaFBhdGllbnRFbmNvdW50ZXJzID0gYXN5bmMgKHBhdGllbnRJZDogc3RyaW5nLCBhY2Nlc3NUb2tlbjogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtGSElSX0JBU0VfVVJMfS9FbmNvdW50ZXI/cGF0aWVudD0ke3BhdGllbnRJZH0mX3NvcnQ9LWRhdGUmX2NvdW50PTEwYCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2ZoaXIranNvbidcbiAgICAgIH1cbiAgICB9KTtcbiAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcGF0aWVudCBlbmNvdW50ZXJzJyk7XG4gICAgfVxuICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiBkYXRhLmVudHJ5ID8gZGF0YS5lbnRyeS5tYXAoKGU6IGFueSkgPT4gZS5yZXNvdXJjZSkgOiBbXTtcbiAgfTtcblxuICBleHBvcnQgY29uc3QgZmV0Y2hQYXRpZW50UHJvY2VkdXJlcyA9IGFzeW5jIChwYXRpZW50SWQ6IHN0cmluZywgYWNjZXNzVG9rZW46IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7RkhJUl9CQVNFX1VSTH0vUHJvY2VkdXJlP3BhdGllbnQ9JHtwYXRpZW50SWR9Jl9zb3J0PS1kYXRlJl9jb3VudD0xMGAsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9maGlyK2pzb24nXG4gICAgICB9XG4gICAgfSk7XG4gIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHBhdGllbnQgcHJvY2VkdXJlcycpO1xuICAgIH1cbiAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YS5lbnRyeSA/IGRhdGEuZW50cnkubWFwKChlOiBhbnkpID0+IGUucmVzb3VyY2UpIDogW107XG4gIH0iXSwibmFtZXMiOlsiRkhJUl9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19GSElSX0JBU0VfVVJMIiwiZmV0Y2hQYXRpZW50RGF0YSIsInBhdGllbnRJZCIsImFjY2Vzc1Rva2VuIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJvayIsIkVycm9yIiwianNvbiIsImZldGNoUGF0aWVudE1lZGljYXRpb25zIiwiZGF0YSIsImVudHJ5IiwibWFwIiwiZSIsInJlc291cmNlIiwiZmV0Y2hQYXRpZW50Vml0YWxzIiwiZmV0Y2hQYXRpZW50QXBwb2ludG1lbnRzIiwiZmV0Y2hQYXRpZW50TGFiUmVwb3J0cyIsImZldGNoUGF0aWVudEVuY291bnRlcnMiLCJmZXRjaFBhdGllbnRQcm9jZWR1cmVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});